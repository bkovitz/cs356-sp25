\documentclass{article}

\input{preamble}

\usepackage{verbatim}

\addbibresource{mobdesign.bib}

\title{Mob Programming in a Software Design Course}

\author{
Ben Kovitz \\
Department of Computer Science \\
California State Polytechnic University, Humboldt \\
Arcata, CA 95521 \\
\email{blk14@humboldt.edu}\\
}

\begin{document}
\maketitle

\begin{abstract}
Case study of a Software Design course taught using mob programming. Mob
programming (also ``team programming'', ``ensemble programming'') is
collaborative programming in which the whole team---in this case, the
whole class---writes code together at the same time, like pair programming
but including everyone. The course combined daily collaborative design and
coding with intensive daily readings and oral presentations. %TODO summarize
%results
\end{abstract}

\section{Introduction}
I taught a course on software design in the Spring~2025 semester at
California State Polytechnic University, Humboldt (course number CS~356),
predominantly by a new pedagogy: mob programming. Mob programming,
also called team programming or ensemble programming, is ``a software
development approach where the whole team works together on the same thing,
in the same space, and at the same computer.''\cite{zuill2022software}
Mob programming is like pair programming, but not limited to two programmers
at one computer.

Several reasons suggested mob programming as an effective way to teach
software design:

\begin{enumerate}
  \item Experience from industry suggests that pair programming and mob
  programming result in knowledge spreading rapidly throughout the team.
  %@@CITE
  So, why not exploit this happy property of mob programming as a class's
  principal method of learning?

  \item Many industry complaints about skills lacking in recent college
  graduates revolve around ``habitability''---the aspects of design that
  go beyond correctness and relate to programmers' ability to work with
  code over many years, such as readability, maintainability, testability,
  and debuggability.\cite{Gabriel1996}. The usual college-course format
  of lectures, homework assignments, and exams often gives students
  experience only with writing small, stand-alone pieces of code that just
  barely work or partly work (enough to get partial credit) and that no one
  looks at ever again. Could mob programming on one project, building it for
  most of one semester by piecemeal growth, give students valuable experience
  working on each other's code, seeing for themselves how to grow a 
  software design that's habitable for others?

  \item Software engineering is a complex and collaborative art.
  Engineers must constantly learn and constantly adjust to unexpected problems
  and to other people on the development team. Much of the skill is difficult
  or impossible to express precisely in verbal representations and procedures,
  and can be acquired only through real practice. This makes it a good fit for
  the research by anthropologists Jean Lave and Etienne Wenger on learning in
  ``communities of practice''.\cite{wenger2015introduction} Could mob
  programming create an artificial community of practice for one semester?

  \item Only seven students were enrolled in the class. CS~356 is a
  junior-level course, and these students were among the first cohorts in the
  university's recently begun Software Engineering degree program. So,
  this semester provided a good opportunity to experiment with mob
  programming.
\end{enumerate}

The rest of this article describes how the course went: its structure,
problems that arose, solutions that we found or didn't find, and a final
assessment.
%Where appropriate, I'll follow a loose version of Portland Form,
%briefly describing each problem and following it with a paragraph marked
%``Solution:'' to indicate the solution chosen.

\section{The Semester}

\begin{comment}
Three problems were evident before the semester began.

First, what is software design, anyway? The term is highly ambiguous.
Different experts hold radically different conceptions, from
James Reeves' view that ``the source code is the
design''\cite{reeves1992software} to IEEE~1016--2009, which specifies
12~``design viewpoints'', each with its own design entities, design
relationships, and design attributes, to be described in a design language
such as UML\cite{IEEE1016-2009}. The number of aspects or elements of software
design is mind-boggling, and each comes with its own opinionated camps and
controversies: high-level design, low-level design, system design, interface
design (which can mean user-interface design, interaction design,
communication protocols, or class method signatures, depending on who's
talking), database design, architectural design, GoF design patterns, ways of
organizing source code into subroutines, and more.

The sea of ambiguity and opinion surrounding ``software design''

Solution: I took the union of all theories of design, and announced on
the first day that the entire field of software design is a matter of
opinion (including this very statement). % TODO throw this out?

% readings & presentations

% time for retrospection
\end{comment}

\subsection{Semester Overview}

The semester plan was as follows. (The complete syllabus is available at
\cite{kovitz2025cs356syllabus}.)

\begin{itemize}
\item Each class session was a lab---no lectures, except for an introductory
lecture on the first day and occasional improvised mini-lectures as needed.
Sessions were one hour and 50~minutes long, twice a week.

\item Readings were assigned at the end of each class session, and students
had to give brief presentations on the readings at the start of the next
session. These presentations usually took up the first 20 to 30 minutes of
class time. The readings came only from sources influential among
professionals, such as books by Martin Fowler and Scott Meyers, as well as
famous blog posts and journal articles, not from textbooks.

\item Students were required to keep notebooks in which they recorded what new
idea or technique they learned in each class session, and to periodically hand
these in during the semester.

\item The first few class sessions: design exercises, mostly omitting
implementation, to teach UML and design as something distinct from code.

\item Most of the semester (about 10~weeks) was spent designing and
implementing a single piece of software in C++, collaboratively by mob
programming together in class.

\item Last two weeks: we returned to design exercises without implementation,
now introducing distributed system design (load balancers, microservices,
etc.).

% MOVE this to "problems"
%AI policy: allowed and encouraged. During the first half of the semester, use
%AI only for documentation look-up and simple code-completion with Copilot.
%During the second half of the semester, run wild and see how much AI can do.

\item Last day of class: each student gave a presentation on what they learned
during the semester.
\end{itemize}

\subsection{Initial Design Exercises}

The first design exercise was borrowed from a job-interview question,
involving designing a state-transition diagram for a controller in a common
home appliance (details omitted so I can reuse it). The students did this in
about an hour of class time, after which I corrected errors and pointed out
that they had worked out a mathematically complete description of the software
without writing a line of code.

Then we moved on to implementing the finite state machine in C++. Had this
been an ordinary class, I would have written the code at a projector,
explaining my thoughts as I went. Instead, we had our first experience with
mob programming, which proved much more educational. We set up our mob
``rotation'' as follows:

\begin{itemize}
\item One person, called the ``driver'', sits at the keyboard of the computer
hooked up to a projector.

\item One person, called the ``navigator'', tells the driver what to do next.

\item Everyone else (``the mob'') watches, checks the code for errors, sees
what ideas come to mind, and does anything else they think might be helpful,
such as adding to-do items to the whiteboard or searching the Internet for
documentation.

\item We followed Llewelyn Falco's ``strong-style
pairing''\cite{falco2014strong}, which has this rule: ``For an idea to go from
your head into the computer, it must go through someone else's hands.'' The
driver does not enter his or her own ideas into the code. The driver's
job is to follow the navigator's instructions. The navigator tries to state
each instruction at the highest level of abstraction that the driver can
implement. That may take the form of ``Now write a test for the null case''
or, if necessary, specific keystrokes to help the driver operate an unfamiliar
text editor.

% TODO Explain the importance of strong-style pairing for verbalizing and
% cooperation

\item We set a timer so that every 5~minutes, we rotated roles. Someone from
the mob becomes the driver, the driver becomes the navigator, and the
navigator returns to the mob.

\item All the students' names were written in sequence (``the rotation'')
on the whiteboard, so we always knew who was to drive next. I placed myself
eighth (last) in the rotation so that every student would have a chance to
navigate before I spoke up.
\end{itemize}

We drew the state-transition diagram on the whiteboard, and then the students
proceeded to do exactly what I think you should not do: they started putting
together tricky nested loops with tricky conditions inside---essentially
neglecting the state-transition diagram and trying to reproduce the desired
output cobbling together familiar programming constructs in the usual ways.
%We
%quickly evolved a style of mobbing where people other than the navigator and
%driver feel free to call out ideas. But I held silent.

At one point, the navigator suggested ``reversing'' a variable for a sensor's
input. The driver didn't know how to do that in C++. The navigator said, ``Put
an exclamation point'' (the Boolean negation operator). The driver was
surprised by how easy that was, got a brief explanation, and then went on to
the next thing. Similar small points came up during mobbing nearly every day.
Students came to the class with widely varying prior experience. Some might be
lost in a lecture that assumes knowledge they don't have and get further
behind as the semester continues.  Mob programming effortlessly paused to fill
in just the bit of knowledge that a student needed, right when he or she
needed it.

%While the course was intended to teach
%``software design'', a rather high-level concept, it also taught a great many
%small details

Eventually the students hit on the idea of a variable for the state of the
state machine. From the mob, I suggested a \texttt{switch} statement,
but they still had no systematic approach and were writing
extremely bug-prone code. Finally, as the navigator, I had the driver make a
\texttt{case} for the \texttt{switch} statement that fully handled the initial
state.  The students had ``aha!'' moments and, as they rotated into the
navigator role one by one, worked out how to systematically cover all of the
infinite set of possible input sequences. On our first attempt to compile the
code, it was correct and passed all tests (which the students were now able to
design systematically, too). The students had their first experience with
\emph{design} distinct from code, and with a systematic mapping of design
elements to program elements.

Some students found the initial mob programming stressful. They'd written
almost all of their previous code solo. Now they had to write code in front of
a whole class---while thinking it up, unsure of their approach, gaps in their
knowledge and skills on display. ``Am I doing it right?'' some asked me after
class, unsure, since I gave them no rubric for ``correct'' mob programming.

A small problem with the physical environment became apparent: the tables in
the lab room were far apart and perpendicular to the projection screen, so it
was awkward to look at the screen, and background noise made it hard to be
heard across the room. We eventually found a quiet room where the seats faced
the projection screen and a new driver could swap into place in a few seconds.
Mobbing can be done hovering around a laptop, but these conveniences help.

After that, we moved on to designing an ATM machine, using Russell Bjork's
ATM Simulation site \cite{bjork_atm_simulation} and following the method of
making classes from nouns in the requirements and assigning responsibilities
based on relationships, as explained in \cite{wirfs1990designing}. We liked
the mob-rotation format so much, we used it for this UML-only, whiteboard-only
design process. There was no navigator role, only a driver role that rotated
every 10~minutes. The driver wrote on the whiteboard while everyone else
suggested items to add or change. Since I was the only one who knew the
process, I facilitated.

\subsection{The Project}

Before the semester, I had asked around campus for software that people needed
written and even received some suggestions on LinkedIn. In class, we rated all
the options at the whiteboard for feasibility, opportunity to learn design
patterns, and suitability for C++, and chose to make a diagram editor. In this
as in all our group decision-making, we followed a method similar to ``dot
voting'' as used at Norman Nielsen Group \cite{budiu2024dotvoting} and
commonly done in mob-programming circles. We kept a clear boundary between
exploration (``divergent thinking'') and evaluation or filtering of ideas
(``convergent thinking''), doing first one and then the other.

We spent one class session brainstorming for features. This gave the
students experience in collaborative software design at the level of
requirements or problem definition. The first idea was ``little boxes in a
canvas''. Exploration continued through ``TiKZ editor'' and, most ambitiously,
``the VSCode of diagram editors, allowing plug-ins for electrical simulation
of schematic diagrams or anything else''. We pared that down to ``enough for
Ben to draw graphs for homework problems in graph theory, with a
\emph{vim}-like user interface.''

Next we had to make a crucial design decision: which GUI library to use?
I assigned readings on two popular and relatively simple libraries, FLTK and
SDL, intending that the students would choose one of those. One student
independently researched Qt, a much more complex library---which I had
intended to avoid. After presentations on all of them and another group
discussion, we chose Qt, attracted by its ability to make a sophisticated
GUI in C++ very quickly and run it on both desktop and mobile platforms,
deeming this to outweigh the risks of greater complexity and time to learn.

I assigned readings in the Qt documentation and we got back to mob
programming. We used Claude.ai to whip up a simple demo app in Qt and we were
convinced we had a winner. But Qt did turn out to be problematic. We spent a
lot of time in and out of class getting the Qt libraries to install
and work with VSCode on the students' various computers and operating systems.
This was chaotic and frustrating---but so is real-life software development,
often for reasons just like this. Qt did enable us to quickly and easily try
out out radical new user-interface ideas, something we likely could not have
done with the other libraries.

The navigator role turned out to induce the most stress. As driver,
you're sitting at the keyboard typing code in front of everyone, but as
navigator, you're standing in front of the everyone and you bear the
responsibility of directing the work. Sometimes a student didn't have ideas
when switching from driver to navigator, or his or her ideas weren't yet clear
enough to tell someone else how to implement them. 

We found that mob programming can work at amazing speed---even as it feels
like you're working slowly, doing just a tiny bit before passing the baton to
the next person.  One day, for example, after we implemented snap-to-grid as
the user moved an object, we had five minutes left, and our next item was to
make the grid visible. One student dove in as navigator and we had Qt
displaying a visible grid just right before class was done.

\begin{comment}
``common knowledge''

The day I improvised a lecture on agile vs. waterfall. Previous exposure had
given some students the impression that agile is hopelessly high-risk
because it has no discipline and other
students the impression that waterfall is hopelessly high-risk because it's
inflexible and assumes perfect forethought.

Some students had previous experience with Git and some did not.

No textbooks.

Hard to teach, easy to teach.

Danger: what if a prima donna shows up?

quiet students not asking questions, not having their problems addressed---not
a problem now
\end{comment}

\subsection{Other Problems and Solutions}

\section{Assessment}

The students reported two main things that they learned from the class:

\begin{enumerate}
\item How to collaborate. The students had all done some pair programming in
earlier classes, but they had never seen collaboration at this intensity. I
had meant for mob programming to give the students broad practical experience
with software design, and it did, but collaboration itself occupied the
starring role.

\item The parts of software development that are too hard to put into words.
For example, how much forethought should you put into code before writing
it? How quickly does refactoring lead a good design to emerge
``spontaneously'' and under what circumstances does this happen or fail to
happen? How much design is overdesign?
\end{enumerate}

The students reported that they got extraordinary practice in oral
communication, partly from the daily oral presentations and partly from the
discipline of verbalizing every design decision that mob programming imposes.

The biggest disappointment of the course was that 10~weeks was not enough to
implement a satisfactory ``graph editor for homework assignments''. Ten weeks
sounds like a long time, but meeting twice a week, it amounts to only
about 30~hours of mob programming.  That's less than a week of work at a
regular job, and it included teaching students many new and unfamiliar design
concepts.

Another disappointment was that the students got only a little exposure to
unit tests and test-driven design. The students all made a test or two in
GoogleTest, but we never used it in the diagram editor, because unit-testing
a GUI is hard. I would recommend in future mob-programming courses to
implement a nontrivial back-end for a web site with a simple interface, or
simply a program that has only a textual user interface.

The course was in some ways easy to teach and in other ways hard to teach.
The students did the lecturing, not me. Most days, I showed up and mobbed more
as a colleague than as a teacher, contributing the same way that I would in
industry. However, the course also required me to pay close attention and
adjust continuously throughout the semester, more than in other classes. While
I had selected a set of readings before the semester, I had to choose and
search for readings before each class to suit whatever the programming was
leadings us to next.

The syllabus listed 78~topics of which I hoped to cover ``some large subset''.
I count about 55 of them touched on or explored to varying degrees:
the DRY principle, \emph{git} and version control, refactoring, code smells, 
the rule of 3 (or 5), smart pointers, Model--View--Controller, adding a level
of indirection, writing the calling code first, YAGNI, the Command pattern, the
Memento pattern, coupling and cohesion, and many more. Most of these topics
came up both the readings and naturally, as they arose in the course of
writing code and talking about it.

% Final exam demonstrated weakness

I am most pleased that the students \emph{know} what the course taught---they
know first-hand, not simply ``because I was told that in college''.
% imperfect knowledge

% course eval numbers

\section{Acknowledgements}

Much gratitude to the many people who helped make the course a success:
Shahzad Aslam-Mir for wide-ranging advice on everything from projects to tools
to C++ libraries, which silently averted disasters and made things run
smoothly; Rebecca Wirfs-Brock for inviting me to look into mob programming and
guidance finding the right balance between giving too much and too little
direction to the students; Woody Zuill for generously making time to answer my
many basic questions about mobbing; Austin Chadwick and Chris Lucian for
generously making time to answer yet more questions about mobbing and letting
me mob remotely at Hunter Industries; Dave Bender for the initial design
exercise;
%Russell Bjork for his ATM simulation;
Sherrene Bogle for creating the
original CS~356 course, making this experiment possible; and most of all to
the students, who dove boldly, cooperatively, and creatively into a wildly
experimental course.

\section{Body of the Manuscript}
The text may be organized into sections and subsections. Please use
\verb+\section+ and  \verb+\subsection+ commands to define them as shown in the
Latex source file of this document. Latex will apply section formatting rules.

\subsection{Abstract}
Provide a one-paragraph brief overview of the paper in both the manuscript for
review and in the final manuscript for publication.

%\subsection{Citation}
%Appropriately cite all references to other published works included in the paper.
%\texttt{biblatex} is used to create a list of references or bibliography as the
%last section in the paper. Here are citation examples for a
%book\cite{latexcompanion}, a journal paper\cite{einstein}, a
%website\cite{knuthwebsite}, and a conference proceeding paper\cite{maurer}.
%Please check out the source code of this document for details.

\subsection{Double Quote}
The proper way to typeset double quote is to use two backticks or grave accents
(\`{}) on the left and two single quotes (\'{}) on the right, e.g.
\`{}\`{}Hello!\'{}\'{} for ``Hello!''.

\subsection{Lists}
Lists are easy to create in  \LaTeX\ whether they are ordered, unordered, or
nested as shown in the following example.

\begin{itemize}[noitemsep]
  \item The individual entries are indicated with a black dot, a so-called bullet.
  \item The text in the entries may be of any length.
\end{itemize}

\begin{enumerate}[noitemsep]
  \item The labels consist of sequential numbers.
  \item The numbers start at 1 with every call to the enumerate environment.
\end{enumerate}

\begin{enumerate}[noitemsep]
   \item The labels consists of sequential numbers.
   \begin{itemize}[noitemsep]
     \item The individual entries are indicated with a black dot, a so-called bullet.
     \item The text in the entries may be of any length.
   \end{itemize}
   \item The numbers start at 1 with every call to the enumerate environment.
\end{enumerate}

\subsection{Math Expressions}
The mass-energy equivalence is described by the famous equation

$$E=mc^2$$

discovered in 1905 by Albert Einstein.
In natural units ($c$ = 1), the formula expresses the identity

\begin{equation}
E=m
\end{equation}

\subsection{Tables and Figures}
Include all tables and figures within the body of the text. (Provide as separate
files in the original format any figures so that if there are problems with the
figures coming into the final manuscript there are alternatives available to the editors.)

Here is an example Table \ref{table:nonlin}. Note that each table or figure \textbf{must} have
a title as our style requirement.

\begin{table}[ht]
\caption{Nonlinear Model Results} % title of Table
\label{table:nonlin} % is used to refer this table in the text
\centering % used for centering table
\begin{tabular}{c c c c} % centered columns (4 columns)
\hline\hline %inserts double horizontal lines
Case & Method\#1 & Method\#2 & Method\#3 \\ [0.5ex] % inserts table
%heading
\hline % inserts single horizontal line
1 & 50 & 837 & 970 \\ % inserting body of the table
2 & 47 & 877 & 230 \\
3 & 31 & 25 & 415 \\
4 & 35 & 144 & 2356 \\
5 & 45 & 300 & 556 \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}
\end{table}

The trim size of the journal is half-letter size, so please be aware that your
tables or figures may be hard to read if the fonts are too small as shown in
this Figure \ref{figure:big_table}.
\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{big_table.png}
\caption{Fonts are too small.}
\label{figure:big_table}
\end{figure}

In this case, you can either divide the table into multiple parts, or put the
table/figure sideways on its own page as shown in Figure \ref{figure:big_table1}.
\begin{sidewaysfigure}[htbp]
  \includegraphics[width=\textwidth]{big_table.png}
  \caption{A big table turned sideways on its own page.}
  \label{figure:big_table1}
\end{sidewaysfigure}

The code for inserting figures sideways is as follows:

\vbox{
\begin{lstlisting}[language=TeX, basicstyle=\footnotesize,
caption=Code to Insert Figures Sideways]
\begin{sidewaysfigure}[htbp]
  \includegraphics[width=\textwidth]{big_table.png}
  \caption{A big table turned sideways on its own page.}
  \label{figure:big_table1}
\end{sidewaysfigure}
\end{lstlisting}
}
Here is a live example: \url{https://www.overleaf.com/read/fzcmnctdppgz}

\subsection{Use of Color}
Even though our digital journal is in color, our print journal is in black and white.
You may choose to use other colors in your paper, but please be aware that the colors
you choose may not be distinguishable after they are turned into gray-scale.

\subsection{Reference List}
The \verb+\printbibliography+ command prints a list of references for you.
Please use \texttt{sample.bib} as an example to create your bibliography entries.

If you can find a reference on \url{https://scholar.google.com/} you can get a
``BibTex'' export by clicking on the quotation mark symbol, which is a lot easier
than entering the information manually.

\subsection{Code Listings}
Commands from \texttt{listings} package allow you to display code easily with
customizable coloring and styling rules. Here is an example.
Please check out the source code of this document for details.

\begin{lstlisting}[language=Python,  caption=Python example]
x = 42
epsilon = 0.01
step = epsilon**2
num_guesses = 0
ans = 0.0
while abs(ans**2-x) > epsilon and ans < x:
    ans = ans + step
    num_guesses += 1
if abs(ans**2-x) <= epsilon:
    print(str(ans) +
    ' is close to the square root of ' +
    str(x))
else:
    print('Failed to find square root of ' + str(x))
print("The number of guesses is " + str(num_guesses))
\end{lstlisting}

\section{Manuscript Submission}
The following materials will need to be submitted:
\begin{enumerate}[noitemsep]
  \item The final manuscript in Latex.
  \item Copyright release. It is essential that we receive the copyright
  release form. By signing this form you are acknowledging that the manuscript
  has not been printed in another venue, plus you are retaining your rights for
  use of the manuscript. Read the copyright release. The Consortium will not
  prohibit you from using the manuscript, but will ask that you credit any reuse
  to the Consortium as the original source of publication. If you misplace the
  copyright form, a generic copyright form can be found through the Copyright
  Release Form\cite{copyright}.\\
  The Consortium encourages multiple presentations of tutorials and workshops.
  If you are presenting a tutorial or workshop you may retain the copyright,
  but we must have that documented. Keep in mind that your manuscript is limited
  to two pages total. However, you must still submit a copyright form.\\
  Please note that it is critical that you obtain permission to use third party
  material. If you use diagrams and such that are attributable to a third party
  you must obtain formal permission to reprint such items, and must so indicate
  in the copyright release as well as submit such permission.
  \item Registration for the conference, along with the appropriate registration
  fee. We have found that there are some folks in need of publication for
  promotion and tenure purposes, and then don’t want to present the paper.
  A major plus of the Consortium conferences is the presentation of the papers,
  and you must plan on attending. If you do not present the paper at the
  conference the paper will be removed from the ACM Digital Library.
  \item A pdf version of your manuscript is most helpful. If there are problems
  with special characters or special formatting this provides the editors with
  what you expected your final manuscript to look like. Providing a pdf version
  or a hard copy helps significantly in envisioning what the author expected
  the final product to look like.
  \item Electronic copies of any graphics in a standard format (bitmap, jpeg, tiff).
\end{enumerate}

\section{Additional Information}
Please feel free to email \verb+ccsc-editors@googlegroups.com+ for questions.
This document is modified from the CCSC manuscript formatting
document\cite{meinke} created by John Meinke.

\medskip

\printbibliography

\end{document}
